esphome:
  name: bluetooth-proxy
  friendly_name: bluetooth-proxy

esp32:
  board: esp32dev
  framework:
    type: esp-idf

api:
  encryption:
    key: !secret encryption_key

bluetooth_proxy:
  active: true

logger:

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret wifi_ssid_fallback
    password: !secret wifi_password_fallback

captive_portal:

web_server:

esp32_ble_tracker:
  on_ble_advertise:
    - then:
        - lambda: |-
            static std::vector<std::string> devices;
            std::string mac = x.address_str();
            std::string name = x.get_name().c_str();
            int rssi = x.get_rssi();

            // Ignore si déjà connu
            for (auto &entry : devices) {
              if (entry.find(mac) == 0) return;
            }

            // Construire une ligne "MAC | Nom | RSSI"
            char buffer[128];
            snprintf(buffer, sizeof(buffer), "%s | %s | %d dBm",
                     mac.c_str(),
                     name.empty() ? "(sans nom)" : name.c_str(),
                     rssi);

            devices.push_back(buffer);

            // Sauvegarde pointeur pour le timer
            id(ble_devices) = &devices;

globals:
  - id: ble_devices
    type: void*
    restore_value: no

interval:
  - interval: 60s
    then:
      - lambda: |-
          auto devices = static_cast<std::vector<std::string>*>(id(ble_devices));
          if (devices == nullptr) return;

          ESP_LOGI("ble_summary", "=== Synthèse BLE (%d périphériques) ===", devices->size());
          for (auto &entry : *devices) {
            ESP_LOGI("ble_summary", "  %s", entry.c_str());
          }
          ESP_LOGI("ble_summary", "======================================");
